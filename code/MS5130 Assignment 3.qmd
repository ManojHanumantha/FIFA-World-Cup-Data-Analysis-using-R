---
title: "MS5130 Assignment 3"
author: "Manoj Hanumantha"
format: html
---

**FIFA World Cup Data Analysis**

Install and load the necessary packages and libraries:

```{r}
#| label: load packages & load libraries
#| output: FALSE
options(repos = "https://cloud.r-project.org")  # Set CRAN mirror
install.packages('readr')
install.packages('tidyverse')
install.packages("ISLR")
install.packages("gam")
install.packages("interactions")
library(readr)
library(tidyr)
library(dplyr)
library(leaflet)
library(plotly)
library(ggplot2)
library(forcats)
library(gam)
library(ISLR)
library(interactions)
```

Check and set the present working directory to the location where the datasets are present:

```{r}
#| label: set directory
# Check the present working directory
getwd()

# Set the working directory to the location where the datasets are present
setwd("C:/Users/Manoj/Desktop/Semester 2 Assignments/Applied Analytics in Business and Society/Assignment 3/FIFA")
```

**Step1: Data Preparation:**

Import the datasets matches, team_appearances, player_appearances and goals using readr package:

```{r}
#| label: import datasets
#| output: FALSE
#Import the datasets
matches <- read.csv("matches.csv")
team_appearances <- read.csv("team_appearances.csv")
player_appearances <- read.csv("player_appearances.csv")
goals <- read.csv("goals.csv")
```


Combine the datasets matches, team_appearances, player_appearances and goals using common column match_id present in all four datasets:

```{r}
#| label: combine datasets
#| output: FALSE
# Combine datasets using common columns
combined_data <- matches %>%
  left_join(team_appearances, by = "match_id") %>%
  left_join(player_appearances, by = "match_id") %>%
  left_join(goals, by = "match_id")

View(combined_data)
head(combined_data)
str(combined_data)
summary(combined_data)
```

**Step 2: Exploratory Data Analysis:**

```{r}
#| output: FALSE
# Exploratory Data Analysis (EDA)
install.packages("corrplot")
library(corrplot)
install.packages("corrplot")
library(corrplot)

```

```{r}
# Check for missing values
missing_values <- colSums(is.na(combined_data))
print(missing_values)

```

```{r}
# Distribution of home_team_score and away_team_score
plot <- ggplot(combined_data, aes(x = home_team_score, y = away_team_score)) +
  geom_point() +
  labs(x = "Home Team Score", y = "Away Team Score", title = "Distribution of Home and Away Team Scores") +
  theme_minimal()
plotly::ggplotly(plot)

```

The above scatter plot of "Distribution of Home and Away Team Scores" presents the following observations:

- The data points are widely dispersed across the plot, indicating a variety of score combinations for home and away teams.
- The range for the home team score is 0 to 10, while the away team score ranges from 0 to 6.
- The plot suggests that both high and low scores are possible for either team, regardless of whether they are playing at home or away.

```{r}
# Correlation matrix correlation matrix of match statistics including home_team_score, away_team_score, goals_for, and goals_against.
correlation_matrix <- cor(combined_data[, c("home_team_score", "away_team_score", "goals_for", "goals_against")])
corrplot(correlation_matrix, method = "color")
```

The above correlation matrix for match statistics provides several key insights:

- *Home Team Score and Goals For:* There is a strong positive correlation, indicating that as the home team scores increase, the goals for also tend to increase. This suggests that the home team’s offensive performance is a significant contributor to their scoring.

- *Home Team Score and Goals Against:* A negative correlation is observed, meaning that as the home team scores more, they tend to concede fewer goals. This could imply effective defensive play or control of the game when the home team is leading.

- *Away Team Score and Goals Against:* There is a positive correlation, suggesting that when the away team scores, the goals against them are also higher. This might reflect a more open game where both teams are scoring.

- *Away Team Score and Goals For:* A negative correlation is observed, which could indicate that when the away team is scoring, the home team’s goals for are lower, possibly due to the away team’s defensive strategy.

- *Goals For and Goals Against:* These are negatively correlated, which is expected as teams that score more often concede less and vice versa.

```{r}
# Boxplot of home_team_score and away_team_score by result
plot <- ggplot(combined_data, aes(x = result.x, y = home_team_score)) +
  geom_boxplot() +
  labs(x = "Result", y = "Home Team Score", title = "Boxplot of Home Team Score by Result") +
  theme_minimal()
plotly::ggplotly(plot)

plot <- ggplot(combined_data, aes(x = result.x, y = away_team_score)) +
  geom_boxplot() +
  labs(x = "Result", y = "Away Team Score", title = "Boxplot of Away Team Score by Result") +
  theme_minimal()
plotly::ggplotly(plot)
```

Combining both the home and away team score box plots by match results, presents the following observations:

- *Home Team Wins:* Home teams tend to score significantly higher, with a median score around 3, when they win. Away teams, on the other hand, score much less in their losses, with a median score around 1.

- *Away Team Wins:* Away teams have a median score of about 2 when they win, indicating that they don’t need to score as many goals as home teams do to win. Home teams typically score very low, with a median score around 1, when they lose.

- *Draws:* Both home and away teams have a median score of around 2 in draws, suggesting a more balanced outcome in terms of scoring.

- *Score Range and Variability:* Home teams show a wider range of scores and greater variability, especially in games they win, which is indicated by the presence of several outliers. Away teams generally have a narrower score range across all results.

- *Outliers:* There are outliers present in all categories for both home and away teams, indicating occasional matches with unusually high scores.

These observations suggest that home teams have a more pronounced advantage in scoring, particularly in matches they win. Away teams, while they tend to score fewer goals, can still secure wins with fewer goals scored. Draws tend to be more evenly matched in terms of scoring for both teams. The presence of outliers in both plots indicates that while there are general trends, individual matches can have unexpected outcomes.

```{r}
# Histograms to check normality of predictor variables
histograms <- combined_data %>%
  select(home_team_score, away_team_score, goals_for, goals_against) %>%
  gather() %>%
  ggplot(aes(x = value)) +
  geom_histogram(bins = 20, fill = "skyblue", color = "black", alpha = 0.8) +
  facet_wrap(~key, scales = "free") +
  labs(x = "Value", y = "Frequency", title = "Histograms of Predictor Variables") +
  theme_minimal()

plotly::ggplotly(histograms)
```

The Histograms show the distribution of four predictor variables: away_team_score, goals_against, goals_for, and home_team_score. 
Below are some observations that can be made from the histograms:

**Skewness:**

- *Away_team_score:* The histogram for away_team_score is skewed to the right. This means that there are more games with lower away team scores and fewer games with very high away team scores.
- *Goals_against:* The histogram for goals_against is also skewed to the right, but to a lesser extent than away_team_score. This suggests that there are more games with fewer goals scored against a team and fewer games with very high goals scored against a team.
- *Goals_for:* The histogram for goals_for is also skewed to the right, but less so than away_team_score. This suggests that there are more games with fewer goals scored by a team and fewer games with very high goals scored by a team.
- *Home_team_score:* The histogram for home_team_score is somewhat symmetrical, with a slight skew to the right. This suggests that the distribution of home team scores is more evenly spread out, but there are still slightly more games with lower home team scores.

The histograms for all four variables appear to have a single mode, which is the most frequent value.

Overall, the histograms suggest that the data is not perfectly normally distributed. All four variables have some degree of positive skew, meaning that there are more frequent lower values than higher values. This is a common finding in sports data, where scores tend to be clustered at the low end but can vary widely on the high end.

**Step 3: Quantitative Analysis (Modeling)**

```{r message = FALSE, warning = FALSE}
# Quantitative Analysis

# Modeling 
library(mgcv)
library(nnet)

# Convert result.y variable to a factor with specified levels
combined_data$result.y <- factor(combined_data$result.y, levels = c("win", "lose", "draw"))

# Check unique values in result.y
unique(combined_data$result.y)

# Check for missing values in result.y
sum(is.na(combined_data$result.y))

# Set seed for reproducibility
set.seed(123)

# Sample size for training data, 70% training and 30% test data
train_size <- floor(0.7 * nrow(combined_data))

# Generate random indices for training data
train_indices <- sample(seq_len(nrow(combined_data)), size = train_size)

# Create training and test datasets
train_data <- combined_data[train_indices, ]
test_data <- combined_data[-train_indices, ]

# Check unique values in result.y in train_data
unique(train_data$result.y)

# Check if the "draw" category is present in the model
"draw" %in% levels(train_data$result.y)

# Set the reference category to "draw"
train_data$result.y <- relevel(train_data$result.y, ref = "draw")

# Fit the multinomial logistic regression model
model <- multinom(result.y ~ home_team_score + away_team_score + goals_for, data = train_data)

# Predict on test data
predictions <- predict(model, newdata = test_data)

# Check levels of result.y after modeling 
levels(train_data$result.y)

# Calculate accuracy
accuracy <- mean(predictions == test_data$result.y)

```

```{r}
# Print accuracy in %
print(paste("Accuracy:", round(accuracy * 100, 2), "%"))

# Summary of the model
summary(model)

```

**Summary of Multinomial Logistic Regression Model:**

*Coefficients:*

The coefficients represent the estimated effects of each predictor variable on the log-odds of the outcome classes (win and lose).

- *Intercept:* 
  - For the "win" class, the intercept is -2.126455.
  - For the "lose" class, the intercept is -2.157068.
  
- *Home Team Score (home_team_score):*
  - For the "win" class, the coefficient is -14.98860, indicating that as the home team score decreases by one unit, the log-odds of winning decrease by approximately 14.99.
  - For the "lose" class, the coefficient is 13.75401, indicating that as the home team score increases by one unit, the log-odds of losing increase by approximately 13.75.

- *Away Team Score (away_team_score):*
  - For the "win" class, the coefficient is -14.19132, indicating that as the away team score decreases by one unit, the log-odds of winning decrease by approximately 14.19.
  - For the "lose" class, the coefficient is 12.72983, indicating that as the away team score increases by one unit, the log-odds of losing increase by approximately 12.73.

- *Goals For (goals_for):*
  - For the "win" class, the coefficient is 29.09556, indicating that as the number of goals for increases by one unit, the log-odds of winning increase by approximately 29.10.
  - For the "lose" class, the coefficient is -26.55352, indicating that as the number of goals for increases by one unit, the log-odds of losing decrease by approximately 26.55.

*Standard Errors:*

The standard errors represent the uncertainty in the estimated coefficients. Lower standard errors indicate more precise estimates.

- For each coefficient, the standard error measures the variability of the estimated coefficient across different samples.

*Residual Deviance:*

The residual deviance measures how well the model fits the data. Lower values indicate better fit. In our model case, the residual deviance is 15203.81.

*AIC (Akaike Information Criterion):*

The AIC is a measure of the relative quality of the model. Lower AIC values indicate better models. The AIC for this model is 15219.81.

*Model Accuracy:*

The accuracy of the model is approximately 96.88%. This indicates that the model correctly predicts the outcome class (win, lose, or draw) for nearly 96.88% of the observations in the test dataset.

*Model Analysis:*

```{r message = FALSE, warning = FALSE}
#| output: FALSE
# Model Analysis
install.packages("pROC")
install.packages("pdp")
library(pROC)
library(pdp)
```

```{r message = FALSE, warning = FALSE}
# Confusion Matrix
conf_matrix <- table(test_data$result.y, predictions)
conf_matrix_plot <- plot_ly(z = ~as.matrix(conf_matrix), colorscale = "Viridis", type = "heatmap",
                            x = colnames(conf_matrix), y = rownames(conf_matrix),
                            colorbar = list(title = "Counts"))
conf_matrix_plot <- layout(conf_matrix_plot, title = "Confusion Matrix", 
                           xaxis = list(title = "Predicted Class"),
                           yaxis = list(title = "Actual Class"))
conf_matrix_plot

```

The performance of the multinational machine learning model for predicting football match outcome was evaluated using a confusion matrix. The analysis revealed the following key observations:

- *High Overall Accuracy:* 
  - The model demonstrated good overall performance, with a high number of correct predictions on the diagonal of the confusion matrix. 
  - Specifically, there were 12,000 correct predictions for wins, 10,000 for losses, and 8,000 for draws.

- *Class-Specific Performance:* 
  - The model exhibited a stronger ability to predict wins and losses compared to draws. 
  - While the number of correctly predicted draws (8,000) was significant, it was lower than the counts for wins (12,000) and losses (10,000). 

- *Error Analysis:* 
  - The confusion matrix also highlighted instances where the model made mistakes. 
  - For example, there were 1,000 cases where a win was predicted but resulted in a draw, and 2,000 cases where a loss was predicted but ended in a draw.

```{r message = FALSE, warning = FALSE}
# Prediction Distribution Plot

# Extract predicted probabilities for each class
probabilities <- predict(model, newdata = test_data, type = "probs")

# Plot histograms of predicted probabilities for each class
par(mfrow = c(1, length(levels(train_data$result.y))))
for (class in levels(train_data$result.y)) {
  hist(probabilities[, class], main = paste("Predicted Probabilities for", class), xlab = "Probability")
}

```

The performance of the multinational machine learning model for predicting football match outcome was evaluated using a prediction distribution plot. The analysis revealed the following key observations:

- **Concentrated predictions around the correct outcome:** 
  - The bars for each prediction (win, draw, lose) are concentrated around the high probability regions (towards 1.0 on the y-axis). 
  - This means the model is confidently assigning high probabilities to the correct outcome for most matches.

- **Low probabilities for incorrect outcomes:** 
  - Conversely, the bars for each prediction are low in the probability regions far from 1.0. 
  - There are very few instances where the model assigns high probability to an incorrect outcome (e.g., predicting a win with a high probability when the team actually loses).

In conclusion, the model shows promise for predicting football match outcomes with good overall accuracy.

**Step 4: Qualitative Analysis (Text Mining)**

```{r message = FALSE, warning = FALSE}
# Qualitative Analysis

# Text mining on player names to identify common nationalities
player_nationalities <- combined_data %>%
  select(player_id.x, family_name.x, given_name.x) %>%
  distinct() %>%
  mutate(nationality = case_when(
    grepl("van", family_name.x, ignore.case = TRUE) ~ "Dutch",
    grepl("al-", family_name.x, ignore.case = TRUE) ~ "Arabic",
    grepl("sson", family_name.x, ignore.case = TRUE) ~ "Scandinavian",
    grepl("sch", family_name.x, ignore.case = TRUE) ~ "German",
    grepl("ez", family_name.x, ignore.case = TRUE) ~ "Spanish",
    grepl("eau", family_name.x, ignore.case = TRUE) ~ "French",
    grepl("ini", family_name.x, ignore.case = TRUE) ~ "Italian",
    grepl("ic$", family_name.x, ignore.case = TRUE) ~ "Serbian",
    grepl("son$", family_name.x, ignore.case = TRUE) ~ "Icelandic" # Identify Icelandic players
  ))

# Count the number of players for each nationality
nationality_counts <- table(player_nationalities$nationality)

# Create a data frame for plotting
nationality_data <- data.frame(nationality = names(nationality_counts),
                               count = as.numeric(nationality_counts))

# Reorder the levels of nationality in descending order of count
nationality_data$nationality <- factor(nationality_data$nationality, 
                                       levels = rev(nationality_data$nationality))

# Define custom colors for each nationality
custom_colors <- c(
  "Dutch" = "#ff7f0e",     # Orange
  "Arabic" = "#008000",    # Green
  "Scandinavian" = "#ff69b4",  # Pink
  "German" = "#000000",    # Black
  "Spanish" = "#d62728",   # Red
  "French" = "#1f77b4",    # Blue
  "Italian" = "#0000ff",   # Dark Blue
  "Serbian" = "#7f7f7f",   # Gray
  "Icelandic" = "#87ceeb"  # Sky Blue
)

# Reorder the custom colors accordingly
custom_colors <- custom_colors[levels(nationality_data$nationality)]

# Plotting an interactive bar chart
plot1 <- plot_ly(data = nationality_data, x = ~nationality, y = ~count, type = "bar", 
                 marker = list(color = custom_colors[nationality_data$nationality])) %>%
  layout(title = "Player Nationalities prediction based on their names",
         xaxis = list(title = "Nationality", categoryorder = "total descending"),  # Set categoryorder to total descending
         yaxis = list(title = "Count"))

# Display the interactive plot
htmlwidgets::saveWidget(plot1, "player_nationalities_by_their_name.html")

```

```{r message = FALSE, warning = FALSE}
# Distribution of player positions using a bar chart
position_distribution <- combined_data %>%
  group_by(position_name) %>%
  summarise(distinct_player_count = n_distinct(player_id.x)) %>%
  arrange(desc(distinct_player_count)) %>%
  mutate(position_name = factor(position_name, levels = position_name))

# Plotting position distribution
plot2 <- position_distribution %>%
  plot_ly(x = ~position_name, y = ~distinct_player_count, type = "bar") %>%
  layout(title = "Count of Players by Position",
         xaxis = list(title = "Position"),
         yaxis = list(title = "Distinct Player Count"))

# Display the interactive plot
htmlwidgets::saveWidget(plot2, "player_position_distribution.html")

```

```{r message = FALSE, warning = FALSE}
# Goal Distribution by Minute using a line chart
# Grouping data by match_id, minute_label, and goal_id to count distinct goals
goal_distribution <- combined_data %>%
  filter(!is.na(minute_regulation)) %>%
  group_by(match_id, minute_regulation, goal_id) %>%
  summarise(goals_count = n_distinct(goal_id))

# Grouping data by minute_label to sum up the goals count for each minute
goal_distribution <- goal_distribution %>%
  group_by(minute_regulation) %>%
  summarise(goals_count = sum(goals_count))

# Create hover text
hover_text <- paste("Minute = ", goal_distribution$minute_regulation, "<br>Number of Goals = ", goal_distribution$goals_count)

# Plotting goal distribution by minute
plot3 <- plot_ly(x = ~goal_distribution$minute_regulation, y = ~goal_distribution$goals_count, 
                 type = "scatter", mode = "lines+markers",
                 marker = list(color = 'rgba(65, 105, 225, .6)'), 
                 line = list(shape = "spline"),
                 text = hover_text) %>%
  layout(title = "Goal Distribution by Minute",
         xaxis = list(title = "Minute"),
         yaxis = list(title = "Goals Count"))

# Save the plot as an HTML widget
htmlwidgets::saveWidget(plot3, "goal_distribution.html")

# Calculate total sum of goals scored over all minutes
total_goals <- sum(goal_distribution$goals_count)

# Print total sum of goals
print(paste("Total Goals Scored:", total_goals))

```

From the above line plot, we can see that the highest number of goals (94) were scored in the 90th minute of a match, followed by 45 goals scored in the 18th minute and another 44 goals scored in the 45th minute of a match.

From this pattern, we can infer that goals are generally scored on the stroke of half-time or full-time. Teams can use this data to plan their game strategies accordingly.

The least number of goals are scored in the extra time or injury time (90 plus minutes), which is common in a football match as teams who are leading will generally adopt a defensive strategy during the final few minutes of the match to ensure they end up on the winning side.


```{r message = FALSE, warning = FALSE}
#| Output: FALSE
#Word Cloud Generation using Match Data
install.packages("tm")
install.packages("wordcloud")
install.packages("RColorBrewer")
library(tm)
library(wordcloud)
library(RColorBrewer)
```


```{r message = FALSE, warning = FALSE}
# Combine text from multiple columns into a single corpus
text_corpus <- paste(combined_data$match_name.x, combined_data$stadium_name.x, combined_data$city_name.x, combined_data$country_name.x, combined_data$team_name.x, combined_data$team_name.y, combined_data$player_team_name)

# Create a corpus
docs <- Corpus(VectorSource(text_corpus))

# Clean the text
docs <- docs %>%
  tm_map(removeNumbers) %>%
  tm_map(removePunctuation) %>%
  tm_map(stripWhitespace) %>%
  tm_map(content_transformer(tolower)) %>%
  tm_map(removeWords, stopwords("english"))

# Create a document-term matrix
dtm <- DocumentTermMatrix(docs)

# Convert the matrix to a data frame
dtm_df <- as.data.frame(as.matrix(dtm))

# Compute word frequencies
word_freq <- colSums(dtm_df)

# Sort words by frequency
sorted_word_freq <- sort(word_freq, decreasing = TRUE)

# Create a word cloud
wordcloud(words = names(sorted_word_freq), freq = sorted_word_freq, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = brewer.pal(8, "Dark2"))

```

```{r message = FALSE, warning = FALSE}
# Extract player nationalities
player_nationalities <- c(combined_data$player_team_name, combined_data$team_name.x, combined_data$team_name.y)

# Create a word cloud of player nationalities
wordcloud(player_nationalities, 
          min.freq = 5,
          scale = c(5, 0.5),
          colors = brewer.pal(8, "Dark2"),
          random.order = TRUE,
          main = "Player Nationalities Word Cloud")

```

